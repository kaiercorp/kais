// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"api_server/ent/migrate"

	"api_server/ent/configuration"
	"api_server/ent/dataset"
	"api_server/ent/datasetroot"
	"api_server/ent/device"
	"api_server/ent/enginelog"
	"api_server/ent/gpu"
	"api_server/ent/hyperparamshistory"
	"api_server/ent/menu"
	"api_server/ent/modeling"
	"api_server/ent/modelingdetails"
	"api_server/ent/modelingmodels"
	"api_server/ent/project"
	"api_server/ent/task"
	"api_server/ent/trial"
	"api_server/ent/trialdetails"
	"api_server/ent/trialstatus"
	"api_server/ent/user"
	"api_server/ent/usergroup"
	"api_server/ent/userproject"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Configuration is the client for interacting with the Configuration builders.
	Configuration *ConfigurationClient
	// Dataset is the client for interacting with the Dataset builders.
	Dataset *DatasetClient
	// DatasetRoot is the client for interacting with the DatasetRoot builders.
	DatasetRoot *DatasetRootClient
	// Device is the client for interacting with the Device builders.
	Device *DeviceClient
	// EngineLog is the client for interacting with the EngineLog builders.
	EngineLog *EngineLogClient
	// Gpu is the client for interacting with the Gpu builders.
	Gpu *GpuClient
	// HyperParamsHistory is the client for interacting with the HyperParamsHistory builders.
	HyperParamsHistory *HyperParamsHistoryClient
	// Menu is the client for interacting with the Menu builders.
	Menu *MenuClient
	// Modeling is the client for interacting with the Modeling builders.
	Modeling *ModelingClient
	// ModelingDetails is the client for interacting with the ModelingDetails builders.
	ModelingDetails *ModelingDetailsClient
	// ModelingModels is the client for interacting with the ModelingModels builders.
	ModelingModels *ModelingModelsClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// Trial is the client for interacting with the Trial builders.
	Trial *TrialClient
	// TrialDetails is the client for interacting with the TrialDetails builders.
	TrialDetails *TrialDetailsClient
	// TrialStatus is the client for interacting with the TrialStatus builders.
	TrialStatus *TrialStatusClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserGroup is the client for interacting with the UserGroup builders.
	UserGroup *UserGroupClient
	// UserProject is the client for interacting with the UserProject builders.
	UserProject *UserProjectClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Configuration = NewConfigurationClient(c.config)
	c.Dataset = NewDatasetClient(c.config)
	c.DatasetRoot = NewDatasetRootClient(c.config)
	c.Device = NewDeviceClient(c.config)
	c.EngineLog = NewEngineLogClient(c.config)
	c.Gpu = NewGpuClient(c.config)
	c.HyperParamsHistory = NewHyperParamsHistoryClient(c.config)
	c.Menu = NewMenuClient(c.config)
	c.Modeling = NewModelingClient(c.config)
	c.ModelingDetails = NewModelingDetailsClient(c.config)
	c.ModelingModels = NewModelingModelsClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.Trial = NewTrialClient(c.config)
	c.TrialDetails = NewTrialDetailsClient(c.config)
	c.TrialStatus = NewTrialStatusClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserGroup = NewUserGroupClient(c.config)
	c.UserProject = NewUserProjectClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Configuration:      NewConfigurationClient(cfg),
		Dataset:            NewDatasetClient(cfg),
		DatasetRoot:        NewDatasetRootClient(cfg),
		Device:             NewDeviceClient(cfg),
		EngineLog:          NewEngineLogClient(cfg),
		Gpu:                NewGpuClient(cfg),
		HyperParamsHistory: NewHyperParamsHistoryClient(cfg),
		Menu:               NewMenuClient(cfg),
		Modeling:           NewModelingClient(cfg),
		ModelingDetails:    NewModelingDetailsClient(cfg),
		ModelingModels:     NewModelingModelsClient(cfg),
		Project:            NewProjectClient(cfg),
		Task:               NewTaskClient(cfg),
		Trial:              NewTrialClient(cfg),
		TrialDetails:       NewTrialDetailsClient(cfg),
		TrialStatus:        NewTrialStatusClient(cfg),
		User:               NewUserClient(cfg),
		UserGroup:          NewUserGroupClient(cfg),
		UserProject:        NewUserProjectClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Configuration:      NewConfigurationClient(cfg),
		Dataset:            NewDatasetClient(cfg),
		DatasetRoot:        NewDatasetRootClient(cfg),
		Device:             NewDeviceClient(cfg),
		EngineLog:          NewEngineLogClient(cfg),
		Gpu:                NewGpuClient(cfg),
		HyperParamsHistory: NewHyperParamsHistoryClient(cfg),
		Menu:               NewMenuClient(cfg),
		Modeling:           NewModelingClient(cfg),
		ModelingDetails:    NewModelingDetailsClient(cfg),
		ModelingModels:     NewModelingModelsClient(cfg),
		Project:            NewProjectClient(cfg),
		Task:               NewTaskClient(cfg),
		Trial:              NewTrialClient(cfg),
		TrialDetails:       NewTrialDetailsClient(cfg),
		TrialStatus:        NewTrialStatusClient(cfg),
		User:               NewUserClient(cfg),
		UserGroup:          NewUserGroupClient(cfg),
		UserProject:        NewUserProjectClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Configuration.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Configuration, c.Dataset, c.DatasetRoot, c.Device, c.EngineLog, c.Gpu,
		c.HyperParamsHistory, c.Menu, c.Modeling, c.ModelingDetails, c.ModelingModels,
		c.Project, c.Task, c.Trial, c.TrialDetails, c.TrialStatus, c.User, c.UserGroup,
		c.UserProject,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Configuration, c.Dataset, c.DatasetRoot, c.Device, c.EngineLog, c.Gpu,
		c.HyperParamsHistory, c.Menu, c.Modeling, c.ModelingDetails, c.ModelingModels,
		c.Project, c.Task, c.Trial, c.TrialDetails, c.TrialStatus, c.User, c.UserGroup,
		c.UserProject,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ConfigurationMutation:
		return c.Configuration.mutate(ctx, m)
	case *DatasetMutation:
		return c.Dataset.mutate(ctx, m)
	case *DatasetRootMutation:
		return c.DatasetRoot.mutate(ctx, m)
	case *DeviceMutation:
		return c.Device.mutate(ctx, m)
	case *EngineLogMutation:
		return c.EngineLog.mutate(ctx, m)
	case *GpuMutation:
		return c.Gpu.mutate(ctx, m)
	case *HyperParamsHistoryMutation:
		return c.HyperParamsHistory.mutate(ctx, m)
	case *MenuMutation:
		return c.Menu.mutate(ctx, m)
	case *ModelingMutation:
		return c.Modeling.mutate(ctx, m)
	case *ModelingDetailsMutation:
		return c.ModelingDetails.mutate(ctx, m)
	case *ModelingModelsMutation:
		return c.ModelingModels.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *TrialMutation:
		return c.Trial.mutate(ctx, m)
	case *TrialDetailsMutation:
		return c.TrialDetails.mutate(ctx, m)
	case *TrialStatusMutation:
		return c.TrialStatus.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserGroupMutation:
		return c.UserGroup.mutate(ctx, m)
	case *UserProjectMutation:
		return c.UserProject.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ConfigurationClient is a client for the Configuration schema.
type ConfigurationClient struct {
	config
}

// NewConfigurationClient returns a client for the Configuration from the given config.
func NewConfigurationClient(c config) *ConfigurationClient {
	return &ConfigurationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `configuration.Hooks(f(g(h())))`.
func (c *ConfigurationClient) Use(hooks ...Hook) {
	c.hooks.Configuration = append(c.hooks.Configuration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `configuration.Intercept(f(g(h())))`.
func (c *ConfigurationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Configuration = append(c.inters.Configuration, interceptors...)
}

// Create returns a builder for creating a Configuration entity.
func (c *ConfigurationClient) Create() *ConfigurationCreate {
	mutation := newConfigurationMutation(c.config, OpCreate)
	return &ConfigurationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Configuration entities.
func (c *ConfigurationClient) CreateBulk(builders ...*ConfigurationCreate) *ConfigurationCreateBulk {
	return &ConfigurationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConfigurationClient) MapCreateBulk(slice any, setFunc func(*ConfigurationCreate, int)) *ConfigurationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConfigurationCreateBulk{err: fmt.Errorf("calling to ConfigurationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConfigurationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConfigurationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Configuration.
func (c *ConfigurationClient) Update() *ConfigurationUpdate {
	mutation := newConfigurationMutation(c.config, OpUpdate)
	return &ConfigurationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConfigurationClient) UpdateOne(co *Configuration) *ConfigurationUpdateOne {
	mutation := newConfigurationMutation(c.config, OpUpdateOne, withConfiguration(co))
	return &ConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConfigurationClient) UpdateOneID(id int) *ConfigurationUpdateOne {
	mutation := newConfigurationMutation(c.config, OpUpdateOne, withConfigurationID(id))
	return &ConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Configuration.
func (c *ConfigurationClient) Delete() *ConfigurationDelete {
	mutation := newConfigurationMutation(c.config, OpDelete)
	return &ConfigurationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConfigurationClient) DeleteOne(co *Configuration) *ConfigurationDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConfigurationClient) DeleteOneID(id int) *ConfigurationDeleteOne {
	builder := c.Delete().Where(configuration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConfigurationDeleteOne{builder}
}

// Query returns a query builder for Configuration.
func (c *ConfigurationClient) Query() *ConfigurationQuery {
	return &ConfigurationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConfiguration},
		inters: c.Interceptors(),
	}
}

// Get returns a Configuration entity by its id.
func (c *ConfigurationClient) Get(ctx context.Context, id int) (*Configuration, error) {
	return c.Query().Where(configuration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConfigurationClient) GetX(ctx context.Context, id int) *Configuration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ConfigurationClient) Hooks() []Hook {
	return c.hooks.Configuration
}

// Interceptors returns the client interceptors.
func (c *ConfigurationClient) Interceptors() []Interceptor {
	return c.inters.Configuration
}

func (c *ConfigurationClient) mutate(ctx context.Context, m *ConfigurationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConfigurationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConfigurationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConfigurationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Configuration mutation op: %q", m.Op())
	}
}

// DatasetClient is a client for the Dataset schema.
type DatasetClient struct {
	config
}

// NewDatasetClient returns a client for the Dataset from the given config.
func NewDatasetClient(c config) *DatasetClient {
	return &DatasetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dataset.Hooks(f(g(h())))`.
func (c *DatasetClient) Use(hooks ...Hook) {
	c.hooks.Dataset = append(c.hooks.Dataset, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dataset.Intercept(f(g(h())))`.
func (c *DatasetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dataset = append(c.inters.Dataset, interceptors...)
}

// Create returns a builder for creating a Dataset entity.
func (c *DatasetClient) Create() *DatasetCreate {
	mutation := newDatasetMutation(c.config, OpCreate)
	return &DatasetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dataset entities.
func (c *DatasetClient) CreateBulk(builders ...*DatasetCreate) *DatasetCreateBulk {
	return &DatasetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DatasetClient) MapCreateBulk(slice any, setFunc func(*DatasetCreate, int)) *DatasetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DatasetCreateBulk{err: fmt.Errorf("calling to DatasetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DatasetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DatasetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dataset.
func (c *DatasetClient) Update() *DatasetUpdate {
	mutation := newDatasetMutation(c.config, OpUpdate)
	return &DatasetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DatasetClient) UpdateOne(d *Dataset) *DatasetUpdateOne {
	mutation := newDatasetMutation(c.config, OpUpdateOne, withDataset(d))
	return &DatasetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DatasetClient) UpdateOneID(id int) *DatasetUpdateOne {
	mutation := newDatasetMutation(c.config, OpUpdateOne, withDatasetID(id))
	return &DatasetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dataset.
func (c *DatasetClient) Delete() *DatasetDelete {
	mutation := newDatasetMutation(c.config, OpDelete)
	return &DatasetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DatasetClient) DeleteOne(d *Dataset) *DatasetDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DatasetClient) DeleteOneID(id int) *DatasetDeleteOne {
	builder := c.Delete().Where(dataset.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DatasetDeleteOne{builder}
}

// Query returns a query builder for Dataset.
func (c *DatasetClient) Query() *DatasetQuery {
	return &DatasetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDataset},
		inters: c.Interceptors(),
	}
}

// Get returns a Dataset entity by its id.
func (c *DatasetClient) Get(ctx context.Context, id int) (*Dataset, error) {
	return c.Query().Where(dataset.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DatasetClient) GetX(ctx context.Context, id int) *Dataset {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDatasetroot queries the datasetroot edge of a Dataset.
func (c *DatasetClient) QueryDatasetroot(d *Dataset) *DatasetRootQuery {
	query := (&DatasetRootClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dataset.Table, dataset.FieldID, id),
			sqlgraph.To(datasetroot.Table, datasetroot.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dataset.DatasetrootTable, dataset.DatasetrootColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DatasetClient) Hooks() []Hook {
	return c.hooks.Dataset
}

// Interceptors returns the client interceptors.
func (c *DatasetClient) Interceptors() []Interceptor {
	return c.inters.Dataset
}

func (c *DatasetClient) mutate(ctx context.Context, m *DatasetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DatasetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DatasetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DatasetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DatasetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dataset mutation op: %q", m.Op())
	}
}

// DatasetRootClient is a client for the DatasetRoot schema.
type DatasetRootClient struct {
	config
}

// NewDatasetRootClient returns a client for the DatasetRoot from the given config.
func NewDatasetRootClient(c config) *DatasetRootClient {
	return &DatasetRootClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `datasetroot.Hooks(f(g(h())))`.
func (c *DatasetRootClient) Use(hooks ...Hook) {
	c.hooks.DatasetRoot = append(c.hooks.DatasetRoot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `datasetroot.Intercept(f(g(h())))`.
func (c *DatasetRootClient) Intercept(interceptors ...Interceptor) {
	c.inters.DatasetRoot = append(c.inters.DatasetRoot, interceptors...)
}

// Create returns a builder for creating a DatasetRoot entity.
func (c *DatasetRootClient) Create() *DatasetRootCreate {
	mutation := newDatasetRootMutation(c.config, OpCreate)
	return &DatasetRootCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DatasetRoot entities.
func (c *DatasetRootClient) CreateBulk(builders ...*DatasetRootCreate) *DatasetRootCreateBulk {
	return &DatasetRootCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DatasetRootClient) MapCreateBulk(slice any, setFunc func(*DatasetRootCreate, int)) *DatasetRootCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DatasetRootCreateBulk{err: fmt.Errorf("calling to DatasetRootClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DatasetRootCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DatasetRootCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DatasetRoot.
func (c *DatasetRootClient) Update() *DatasetRootUpdate {
	mutation := newDatasetRootMutation(c.config, OpUpdate)
	return &DatasetRootUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DatasetRootClient) UpdateOne(dr *DatasetRoot) *DatasetRootUpdateOne {
	mutation := newDatasetRootMutation(c.config, OpUpdateOne, withDatasetRoot(dr))
	return &DatasetRootUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DatasetRootClient) UpdateOneID(id int) *DatasetRootUpdateOne {
	mutation := newDatasetRootMutation(c.config, OpUpdateOne, withDatasetRootID(id))
	return &DatasetRootUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DatasetRoot.
func (c *DatasetRootClient) Delete() *DatasetRootDelete {
	mutation := newDatasetRootMutation(c.config, OpDelete)
	return &DatasetRootDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DatasetRootClient) DeleteOne(dr *DatasetRoot) *DatasetRootDeleteOne {
	return c.DeleteOneID(dr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DatasetRootClient) DeleteOneID(id int) *DatasetRootDeleteOne {
	builder := c.Delete().Where(datasetroot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DatasetRootDeleteOne{builder}
}

// Query returns a query builder for DatasetRoot.
func (c *DatasetRootClient) Query() *DatasetRootQuery {
	return &DatasetRootQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDatasetRoot},
		inters: c.Interceptors(),
	}
}

// Get returns a DatasetRoot entity by its id.
func (c *DatasetRootClient) Get(ctx context.Context, id int) (*DatasetRoot, error) {
	return c.Query().Where(datasetroot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DatasetRootClient) GetX(ctx context.Context, id int) *DatasetRoot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDatasets queries the datasets edge of a DatasetRoot.
func (c *DatasetRootClient) QueryDatasets(dr *DatasetRoot) *DatasetQuery {
	query := (&DatasetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(datasetroot.Table, datasetroot.FieldID, id),
			sqlgraph.To(dataset.Table, dataset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, datasetroot.DatasetsTable, datasetroot.DatasetsColumn),
		)
		fromV = sqlgraph.Neighbors(dr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DatasetRootClient) Hooks() []Hook {
	return c.hooks.DatasetRoot
}

// Interceptors returns the client interceptors.
func (c *DatasetRootClient) Interceptors() []Interceptor {
	return c.inters.DatasetRoot
}

func (c *DatasetRootClient) mutate(ctx context.Context, m *DatasetRootMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DatasetRootCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DatasetRootUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DatasetRootUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DatasetRootDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DatasetRoot mutation op: %q", m.Op())
	}
}

// DeviceClient is a client for the Device schema.
type DeviceClient struct {
	config
}

// NewDeviceClient returns a client for the Device from the given config.
func NewDeviceClient(c config) *DeviceClient {
	return &DeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `device.Hooks(f(g(h())))`.
func (c *DeviceClient) Use(hooks ...Hook) {
	c.hooks.Device = append(c.hooks.Device, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `device.Intercept(f(g(h())))`.
func (c *DeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Device = append(c.inters.Device, interceptors...)
}

// Create returns a builder for creating a Device entity.
func (c *DeviceClient) Create() *DeviceCreate {
	mutation := newDeviceMutation(c.config, OpCreate)
	return &DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Device entities.
func (c *DeviceClient) CreateBulk(builders ...*DeviceCreate) *DeviceCreateBulk {
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceClient) MapCreateBulk(slice any, setFunc func(*DeviceCreate, int)) *DeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceCreateBulk{err: fmt.Errorf("calling to DeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Device.
func (c *DeviceClient) Update() *DeviceUpdate {
	mutation := newDeviceMutation(c.config, OpUpdate)
	return &DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceClient) UpdateOne(d *Device) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDevice(d))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceClient) UpdateOneID(id int) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDeviceID(id))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Device.
func (c *DeviceClient) Delete() *DeviceDelete {
	mutation := newDeviceMutation(c.config, OpDelete)
	return &DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceClient) DeleteOne(d *Device) *DeviceDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceClient) DeleteOneID(id int) *DeviceDeleteOne {
	builder := c.Delete().Where(device.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceDeleteOne{builder}
}

// Query returns a query builder for Device.
func (c *DeviceClient) Query() *DeviceQuery {
	return &DeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a Device entity by its id.
func (c *DeviceClient) Get(ctx context.Context, id int) (*Device, error) {
	return c.Query().Where(device.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceClient) GetX(ctx context.Context, id int) *Device {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGpu queries the gpu edge of a Device.
func (c *DeviceClient) QueryGpu(d *Device) *GpuQuery {
	query := (&GpuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(gpu.Table, gpu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.GpuTable, device.GpuColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceClient) Hooks() []Hook {
	return c.hooks.Device
}

// Interceptors returns the client interceptors.
func (c *DeviceClient) Interceptors() []Interceptor {
	return c.inters.Device
}

func (c *DeviceClient) mutate(ctx context.Context, m *DeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Device mutation op: %q", m.Op())
	}
}

// EngineLogClient is a client for the EngineLog schema.
type EngineLogClient struct {
	config
}

// NewEngineLogClient returns a client for the EngineLog from the given config.
func NewEngineLogClient(c config) *EngineLogClient {
	return &EngineLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `enginelog.Hooks(f(g(h())))`.
func (c *EngineLogClient) Use(hooks ...Hook) {
	c.hooks.EngineLog = append(c.hooks.EngineLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `enginelog.Intercept(f(g(h())))`.
func (c *EngineLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.EngineLog = append(c.inters.EngineLog, interceptors...)
}

// Create returns a builder for creating a EngineLog entity.
func (c *EngineLogClient) Create() *EngineLogCreate {
	mutation := newEngineLogMutation(c.config, OpCreate)
	return &EngineLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EngineLog entities.
func (c *EngineLogClient) CreateBulk(builders ...*EngineLogCreate) *EngineLogCreateBulk {
	return &EngineLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EngineLogClient) MapCreateBulk(slice any, setFunc func(*EngineLogCreate, int)) *EngineLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EngineLogCreateBulk{err: fmt.Errorf("calling to EngineLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EngineLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EngineLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EngineLog.
func (c *EngineLogClient) Update() *EngineLogUpdate {
	mutation := newEngineLogMutation(c.config, OpUpdate)
	return &EngineLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EngineLogClient) UpdateOne(el *EngineLog) *EngineLogUpdateOne {
	mutation := newEngineLogMutation(c.config, OpUpdateOne, withEngineLog(el))
	return &EngineLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EngineLogClient) UpdateOneID(id int) *EngineLogUpdateOne {
	mutation := newEngineLogMutation(c.config, OpUpdateOne, withEngineLogID(id))
	return &EngineLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EngineLog.
func (c *EngineLogClient) Delete() *EngineLogDelete {
	mutation := newEngineLogMutation(c.config, OpDelete)
	return &EngineLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EngineLogClient) DeleteOne(el *EngineLog) *EngineLogDeleteOne {
	return c.DeleteOneID(el.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EngineLogClient) DeleteOneID(id int) *EngineLogDeleteOne {
	builder := c.Delete().Where(enginelog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EngineLogDeleteOne{builder}
}

// Query returns a query builder for EngineLog.
func (c *EngineLogClient) Query() *EngineLogQuery {
	return &EngineLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEngineLog},
		inters: c.Interceptors(),
	}
}

// Get returns a EngineLog entity by its id.
func (c *EngineLogClient) Get(ctx context.Context, id int) (*EngineLog, error) {
	return c.Query().Where(enginelog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EngineLogClient) GetX(ctx context.Context, id int) *EngineLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EngineLogClient) Hooks() []Hook {
	return c.hooks.EngineLog
}

// Interceptors returns the client interceptors.
func (c *EngineLogClient) Interceptors() []Interceptor {
	return c.inters.EngineLog
}

func (c *EngineLogClient) mutate(ctx context.Context, m *EngineLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EngineLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EngineLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EngineLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EngineLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EngineLog mutation op: %q", m.Op())
	}
}

// GpuClient is a client for the Gpu schema.
type GpuClient struct {
	config
}

// NewGpuClient returns a client for the Gpu from the given config.
func NewGpuClient(c config) *GpuClient {
	return &GpuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gpu.Hooks(f(g(h())))`.
func (c *GpuClient) Use(hooks ...Hook) {
	c.hooks.Gpu = append(c.hooks.Gpu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gpu.Intercept(f(g(h())))`.
func (c *GpuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Gpu = append(c.inters.Gpu, interceptors...)
}

// Create returns a builder for creating a Gpu entity.
func (c *GpuClient) Create() *GpuCreate {
	mutation := newGpuMutation(c.config, OpCreate)
	return &GpuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Gpu entities.
func (c *GpuClient) CreateBulk(builders ...*GpuCreate) *GpuCreateBulk {
	return &GpuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GpuClient) MapCreateBulk(slice any, setFunc func(*GpuCreate, int)) *GpuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GpuCreateBulk{err: fmt.Errorf("calling to GpuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GpuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GpuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Gpu.
func (c *GpuClient) Update() *GpuUpdate {
	mutation := newGpuMutation(c.config, OpUpdate)
	return &GpuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GpuClient) UpdateOne(gp *Gpu) *GpuUpdateOne {
	mutation := newGpuMutation(c.config, OpUpdateOne, withGpu(gp))
	return &GpuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GpuClient) UpdateOneID(id int) *GpuUpdateOne {
	mutation := newGpuMutation(c.config, OpUpdateOne, withGpuID(id))
	return &GpuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Gpu.
func (c *GpuClient) Delete() *GpuDelete {
	mutation := newGpuMutation(c.config, OpDelete)
	return &GpuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GpuClient) DeleteOne(gp *Gpu) *GpuDeleteOne {
	return c.DeleteOneID(gp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GpuClient) DeleteOneID(id int) *GpuDeleteOne {
	builder := c.Delete().Where(gpu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GpuDeleteOne{builder}
}

// Query returns a query builder for Gpu.
func (c *GpuClient) Query() *GpuQuery {
	return &GpuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGpu},
		inters: c.Interceptors(),
	}
}

// Get returns a Gpu entity by its id.
func (c *GpuClient) Get(ctx context.Context, id int) (*Gpu, error) {
	return c.Query().Where(gpu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GpuClient) GetX(ctx context.Context, id int) *Gpu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDevice queries the device edge of a Gpu.
func (c *GpuClient) QueryDevice(gp *Gpu) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gpu.Table, gpu.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gpu.DeviceTable, gpu.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GpuClient) Hooks() []Hook {
	return c.hooks.Gpu
}

// Interceptors returns the client interceptors.
func (c *GpuClient) Interceptors() []Interceptor {
	return c.inters.Gpu
}

func (c *GpuClient) mutate(ctx context.Context, m *GpuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GpuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GpuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GpuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GpuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Gpu mutation op: %q", m.Op())
	}
}

// HyperParamsHistoryClient is a client for the HyperParamsHistory schema.
type HyperParamsHistoryClient struct {
	config
}

// NewHyperParamsHistoryClient returns a client for the HyperParamsHistory from the given config.
func NewHyperParamsHistoryClient(c config) *HyperParamsHistoryClient {
	return &HyperParamsHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hyperparamshistory.Hooks(f(g(h())))`.
func (c *HyperParamsHistoryClient) Use(hooks ...Hook) {
	c.hooks.HyperParamsHistory = append(c.hooks.HyperParamsHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hyperparamshistory.Intercept(f(g(h())))`.
func (c *HyperParamsHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.HyperParamsHistory = append(c.inters.HyperParamsHistory, interceptors...)
}

// Create returns a builder for creating a HyperParamsHistory entity.
func (c *HyperParamsHistoryClient) Create() *HyperParamsHistoryCreate {
	mutation := newHyperParamsHistoryMutation(c.config, OpCreate)
	return &HyperParamsHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HyperParamsHistory entities.
func (c *HyperParamsHistoryClient) CreateBulk(builders ...*HyperParamsHistoryCreate) *HyperParamsHistoryCreateBulk {
	return &HyperParamsHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HyperParamsHistoryClient) MapCreateBulk(slice any, setFunc func(*HyperParamsHistoryCreate, int)) *HyperParamsHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HyperParamsHistoryCreateBulk{err: fmt.Errorf("calling to HyperParamsHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HyperParamsHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HyperParamsHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HyperParamsHistory.
func (c *HyperParamsHistoryClient) Update() *HyperParamsHistoryUpdate {
	mutation := newHyperParamsHistoryMutation(c.config, OpUpdate)
	return &HyperParamsHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HyperParamsHistoryClient) UpdateOne(hph *HyperParamsHistory) *HyperParamsHistoryUpdateOne {
	mutation := newHyperParamsHistoryMutation(c.config, OpUpdateOne, withHyperParamsHistory(hph))
	return &HyperParamsHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HyperParamsHistoryClient) UpdateOneID(id int) *HyperParamsHistoryUpdateOne {
	mutation := newHyperParamsHistoryMutation(c.config, OpUpdateOne, withHyperParamsHistoryID(id))
	return &HyperParamsHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HyperParamsHistory.
func (c *HyperParamsHistoryClient) Delete() *HyperParamsHistoryDelete {
	mutation := newHyperParamsHistoryMutation(c.config, OpDelete)
	return &HyperParamsHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HyperParamsHistoryClient) DeleteOne(hph *HyperParamsHistory) *HyperParamsHistoryDeleteOne {
	return c.DeleteOneID(hph.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HyperParamsHistoryClient) DeleteOneID(id int) *HyperParamsHistoryDeleteOne {
	builder := c.Delete().Where(hyperparamshistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HyperParamsHistoryDeleteOne{builder}
}

// Query returns a query builder for HyperParamsHistory.
func (c *HyperParamsHistoryClient) Query() *HyperParamsHistoryQuery {
	return &HyperParamsHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHyperParamsHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a HyperParamsHistory entity by its id.
func (c *HyperParamsHistoryClient) Get(ctx context.Context, id int) (*HyperParamsHistory, error) {
	return c.Query().Where(hyperparamshistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HyperParamsHistoryClient) GetX(ctx context.Context, id int) *HyperParamsHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *HyperParamsHistoryClient) Hooks() []Hook {
	return c.hooks.HyperParamsHistory
}

// Interceptors returns the client interceptors.
func (c *HyperParamsHistoryClient) Interceptors() []Interceptor {
	return c.inters.HyperParamsHistory
}

func (c *HyperParamsHistoryClient) mutate(ctx context.Context, m *HyperParamsHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HyperParamsHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HyperParamsHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HyperParamsHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HyperParamsHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HyperParamsHistory mutation op: %q", m.Op())
	}
}

// MenuClient is a client for the Menu schema.
type MenuClient struct {
	config
}

// NewMenuClient returns a client for the Menu from the given config.
func NewMenuClient(c config) *MenuClient {
	return &MenuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menu.Hooks(f(g(h())))`.
func (c *MenuClient) Use(hooks ...Hook) {
	c.hooks.Menu = append(c.hooks.Menu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menu.Intercept(f(g(h())))`.
func (c *MenuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Menu = append(c.inters.Menu, interceptors...)
}

// Create returns a builder for creating a Menu entity.
func (c *MenuClient) Create() *MenuCreate {
	mutation := newMenuMutation(c.config, OpCreate)
	return &MenuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Menu entities.
func (c *MenuClient) CreateBulk(builders ...*MenuCreate) *MenuCreateBulk {
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuClient) MapCreateBulk(slice any, setFunc func(*MenuCreate, int)) *MenuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuCreateBulk{err: fmt.Errorf("calling to MenuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Menu.
func (c *MenuClient) Update() *MenuUpdate {
	mutation := newMenuMutation(c.config, OpUpdate)
	return &MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuClient) UpdateOne(m *Menu) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenu(m))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuClient) UpdateOneID(id string) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenuID(id))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Menu.
func (c *MenuClient) Delete() *MenuDelete {
	mutation := newMenuMutation(c.config, OpDelete)
	return &MenuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuClient) DeleteOne(m *Menu) *MenuDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuClient) DeleteOneID(id string) *MenuDeleteOne {
	builder := c.Delete().Where(menu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuDeleteOne{builder}
}

// Query returns a query builder for Menu.
func (c *MenuClient) Query() *MenuQuery {
	return &MenuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenu},
		inters: c.Interceptors(),
	}
}

// Get returns a Menu entity by its id.
func (c *MenuClient) Get(ctx context.Context, id string) (*Menu, error) {
	return c.Query().Where(menu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuClient) GetX(ctx context.Context, id string) *Menu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a Menu.
func (c *MenuClient) QueryParent(m *Menu) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, menu.ParentTable, menu.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Menu.
func (c *MenuClient) QueryChildren(m *Menu) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.ChildrenTable, menu.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuClient) Hooks() []Hook {
	return c.hooks.Menu
}

// Interceptors returns the client interceptors.
func (c *MenuClient) Interceptors() []Interceptor {
	return c.inters.Menu
}

func (c *MenuClient) mutate(ctx context.Context, m *MenuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Menu mutation op: %q", m.Op())
	}
}

// ModelingClient is a client for the Modeling schema.
type ModelingClient struct {
	config
}

// NewModelingClient returns a client for the Modeling from the given config.
func NewModelingClient(c config) *ModelingClient {
	return &ModelingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `modeling.Hooks(f(g(h())))`.
func (c *ModelingClient) Use(hooks ...Hook) {
	c.hooks.Modeling = append(c.hooks.Modeling, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `modeling.Intercept(f(g(h())))`.
func (c *ModelingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Modeling = append(c.inters.Modeling, interceptors...)
}

// Create returns a builder for creating a Modeling entity.
func (c *ModelingClient) Create() *ModelingCreate {
	mutation := newModelingMutation(c.config, OpCreate)
	return &ModelingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Modeling entities.
func (c *ModelingClient) CreateBulk(builders ...*ModelingCreate) *ModelingCreateBulk {
	return &ModelingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ModelingClient) MapCreateBulk(slice any, setFunc func(*ModelingCreate, int)) *ModelingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ModelingCreateBulk{err: fmt.Errorf("calling to ModelingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ModelingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ModelingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Modeling.
func (c *ModelingClient) Update() *ModelingUpdate {
	mutation := newModelingMutation(c.config, OpUpdate)
	return &ModelingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ModelingClient) UpdateOne(m *Modeling) *ModelingUpdateOne {
	mutation := newModelingMutation(c.config, OpUpdateOne, withModeling(m))
	return &ModelingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ModelingClient) UpdateOneID(id int) *ModelingUpdateOne {
	mutation := newModelingMutation(c.config, OpUpdateOne, withModelingID(id))
	return &ModelingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Modeling.
func (c *ModelingClient) Delete() *ModelingDelete {
	mutation := newModelingMutation(c.config, OpDelete)
	return &ModelingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ModelingClient) DeleteOne(m *Modeling) *ModelingDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ModelingClient) DeleteOneID(id int) *ModelingDeleteOne {
	builder := c.Delete().Where(modeling.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ModelingDeleteOne{builder}
}

// Query returns a query builder for Modeling.
func (c *ModelingClient) Query() *ModelingQuery {
	return &ModelingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeModeling},
		inters: c.Interceptors(),
	}
}

// Get returns a Modeling entity by its id.
func (c *ModelingClient) Get(ctx context.Context, id int) (*Modeling, error) {
	return c.Query().Where(modeling.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ModelingClient) GetX(ctx context.Context, id int) *Modeling {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTask queries the task edge of a Modeling.
func (c *ModelingClient) QueryTask(m *Modeling) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(modeling.Table, modeling.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, modeling.TaskTable, modeling.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryModelingDetails queries the modeling_details edge of a Modeling.
func (c *ModelingClient) QueryModelingDetails(m *Modeling) *ModelingDetailsQuery {
	query := (&ModelingDetailsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(modeling.Table, modeling.FieldID, id),
			sqlgraph.To(modelingdetails.Table, modelingdetails.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, modeling.ModelingDetailsTable, modeling.ModelingDetailsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryModelingModels queries the modeling_models edge of a Modeling.
func (c *ModelingClient) QueryModelingModels(m *Modeling) *ModelingModelsQuery {
	query := (&ModelingModelsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(modeling.Table, modeling.FieldID, id),
			sqlgraph.To(modelingmodels.Table, modelingmodels.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, modeling.ModelingModelsTable, modeling.ModelingModelsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrials queries the trials edge of a Modeling.
func (c *ModelingClient) QueryTrials(m *Modeling) *TrialQuery {
	query := (&TrialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(modeling.Table, modeling.FieldID, id),
			sqlgraph.To(trial.Table, trial.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, modeling.TrialsTable, modeling.TrialsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ModelingClient) Hooks() []Hook {
	return c.hooks.Modeling
}

// Interceptors returns the client interceptors.
func (c *ModelingClient) Interceptors() []Interceptor {
	return c.inters.Modeling
}

func (c *ModelingClient) mutate(ctx context.Context, m *ModelingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ModelingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ModelingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ModelingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ModelingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Modeling mutation op: %q", m.Op())
	}
}

// ModelingDetailsClient is a client for the ModelingDetails schema.
type ModelingDetailsClient struct {
	config
}

// NewModelingDetailsClient returns a client for the ModelingDetails from the given config.
func NewModelingDetailsClient(c config) *ModelingDetailsClient {
	return &ModelingDetailsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `modelingdetails.Hooks(f(g(h())))`.
func (c *ModelingDetailsClient) Use(hooks ...Hook) {
	c.hooks.ModelingDetails = append(c.hooks.ModelingDetails, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `modelingdetails.Intercept(f(g(h())))`.
func (c *ModelingDetailsClient) Intercept(interceptors ...Interceptor) {
	c.inters.ModelingDetails = append(c.inters.ModelingDetails, interceptors...)
}

// Create returns a builder for creating a ModelingDetails entity.
func (c *ModelingDetailsClient) Create() *ModelingDetailsCreate {
	mutation := newModelingDetailsMutation(c.config, OpCreate)
	return &ModelingDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ModelingDetails entities.
func (c *ModelingDetailsClient) CreateBulk(builders ...*ModelingDetailsCreate) *ModelingDetailsCreateBulk {
	return &ModelingDetailsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ModelingDetailsClient) MapCreateBulk(slice any, setFunc func(*ModelingDetailsCreate, int)) *ModelingDetailsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ModelingDetailsCreateBulk{err: fmt.Errorf("calling to ModelingDetailsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ModelingDetailsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ModelingDetailsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ModelingDetails.
func (c *ModelingDetailsClient) Update() *ModelingDetailsUpdate {
	mutation := newModelingDetailsMutation(c.config, OpUpdate)
	return &ModelingDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ModelingDetailsClient) UpdateOne(md *ModelingDetails) *ModelingDetailsUpdateOne {
	mutation := newModelingDetailsMutation(c.config, OpUpdateOne, withModelingDetails(md))
	return &ModelingDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ModelingDetailsClient) UpdateOneID(id int) *ModelingDetailsUpdateOne {
	mutation := newModelingDetailsMutation(c.config, OpUpdateOne, withModelingDetailsID(id))
	return &ModelingDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ModelingDetails.
func (c *ModelingDetailsClient) Delete() *ModelingDetailsDelete {
	mutation := newModelingDetailsMutation(c.config, OpDelete)
	return &ModelingDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ModelingDetailsClient) DeleteOne(md *ModelingDetails) *ModelingDetailsDeleteOne {
	return c.DeleteOneID(md.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ModelingDetailsClient) DeleteOneID(id int) *ModelingDetailsDeleteOne {
	builder := c.Delete().Where(modelingdetails.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ModelingDetailsDeleteOne{builder}
}

// Query returns a query builder for ModelingDetails.
func (c *ModelingDetailsClient) Query() *ModelingDetailsQuery {
	return &ModelingDetailsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeModelingDetails},
		inters: c.Interceptors(),
	}
}

// Get returns a ModelingDetails entity by its id.
func (c *ModelingDetailsClient) Get(ctx context.Context, id int) (*ModelingDetails, error) {
	return c.Query().Where(modelingdetails.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ModelingDetailsClient) GetX(ctx context.Context, id int) *ModelingDetails {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryModeling queries the modeling edge of a ModelingDetails.
func (c *ModelingDetailsClient) QueryModeling(md *ModelingDetails) *ModelingQuery {
	query := (&ModelingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := md.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(modelingdetails.Table, modelingdetails.FieldID, id),
			sqlgraph.To(modeling.Table, modeling.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, modelingdetails.ModelingTable, modelingdetails.ModelingColumn),
		)
		fromV = sqlgraph.Neighbors(md.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ModelingDetailsClient) Hooks() []Hook {
	return c.hooks.ModelingDetails
}

// Interceptors returns the client interceptors.
func (c *ModelingDetailsClient) Interceptors() []Interceptor {
	return c.inters.ModelingDetails
}

func (c *ModelingDetailsClient) mutate(ctx context.Context, m *ModelingDetailsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ModelingDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ModelingDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ModelingDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ModelingDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ModelingDetails mutation op: %q", m.Op())
	}
}

// ModelingModelsClient is a client for the ModelingModels schema.
type ModelingModelsClient struct {
	config
}

// NewModelingModelsClient returns a client for the ModelingModels from the given config.
func NewModelingModelsClient(c config) *ModelingModelsClient {
	return &ModelingModelsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `modelingmodels.Hooks(f(g(h())))`.
func (c *ModelingModelsClient) Use(hooks ...Hook) {
	c.hooks.ModelingModels = append(c.hooks.ModelingModels, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `modelingmodels.Intercept(f(g(h())))`.
func (c *ModelingModelsClient) Intercept(interceptors ...Interceptor) {
	c.inters.ModelingModels = append(c.inters.ModelingModels, interceptors...)
}

// Create returns a builder for creating a ModelingModels entity.
func (c *ModelingModelsClient) Create() *ModelingModelsCreate {
	mutation := newModelingModelsMutation(c.config, OpCreate)
	return &ModelingModelsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ModelingModels entities.
func (c *ModelingModelsClient) CreateBulk(builders ...*ModelingModelsCreate) *ModelingModelsCreateBulk {
	return &ModelingModelsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ModelingModelsClient) MapCreateBulk(slice any, setFunc func(*ModelingModelsCreate, int)) *ModelingModelsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ModelingModelsCreateBulk{err: fmt.Errorf("calling to ModelingModelsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ModelingModelsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ModelingModelsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ModelingModels.
func (c *ModelingModelsClient) Update() *ModelingModelsUpdate {
	mutation := newModelingModelsMutation(c.config, OpUpdate)
	return &ModelingModelsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ModelingModelsClient) UpdateOne(mm *ModelingModels) *ModelingModelsUpdateOne {
	mutation := newModelingModelsMutation(c.config, OpUpdateOne, withModelingModels(mm))
	return &ModelingModelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ModelingModelsClient) UpdateOneID(id int) *ModelingModelsUpdateOne {
	mutation := newModelingModelsMutation(c.config, OpUpdateOne, withModelingModelsID(id))
	return &ModelingModelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ModelingModels.
func (c *ModelingModelsClient) Delete() *ModelingModelsDelete {
	mutation := newModelingModelsMutation(c.config, OpDelete)
	return &ModelingModelsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ModelingModelsClient) DeleteOne(mm *ModelingModels) *ModelingModelsDeleteOne {
	return c.DeleteOneID(mm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ModelingModelsClient) DeleteOneID(id int) *ModelingModelsDeleteOne {
	builder := c.Delete().Where(modelingmodels.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ModelingModelsDeleteOne{builder}
}

// Query returns a query builder for ModelingModels.
func (c *ModelingModelsClient) Query() *ModelingModelsQuery {
	return &ModelingModelsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeModelingModels},
		inters: c.Interceptors(),
	}
}

// Get returns a ModelingModels entity by its id.
func (c *ModelingModelsClient) Get(ctx context.Context, id int) (*ModelingModels, error) {
	return c.Query().Where(modelingmodels.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ModelingModelsClient) GetX(ctx context.Context, id int) *ModelingModels {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryModeling queries the modeling edge of a ModelingModels.
func (c *ModelingModelsClient) QueryModeling(mm *ModelingModels) *ModelingQuery {
	query := (&ModelingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(modelingmodels.Table, modelingmodels.FieldID, id),
			sqlgraph.To(modeling.Table, modeling.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, modelingmodels.ModelingTable, modelingmodels.ModelingColumn),
		)
		fromV = sqlgraph.Neighbors(mm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ModelingModelsClient) Hooks() []Hook {
	return c.hooks.ModelingModels
}

// Interceptors returns the client interceptors.
func (c *ModelingModelsClient) Interceptors() []Interceptor {
	return c.inters.ModelingModels
}

func (c *ModelingModelsClient) mutate(ctx context.Context, m *ModelingModelsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ModelingModelsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ModelingModelsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ModelingModelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ModelingModelsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ModelingModels mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectClient) MapCreateBulk(slice any, setFunc func(*ProjectCreate, int)) *ProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectCreateBulk{err: fmt.Errorf("calling to ProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id int) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id int) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id int) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id int) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTasks queries the tasks edge of a Project.
func (c *ProjectClient) QueryTasks(pr *Project) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.TasksTable, project.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserProject queries the user_project edge of a Project.
func (c *ProjectClient) QueryUserProject(pr *Project) *UserProjectQuery {
	query := (&UserProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(userproject.Table, userproject.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.UserProjectTable, project.UserProjectColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	return c.inters.Project
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Project mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id int) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id int) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id int) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id int) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Task.
func (c *TaskClient) QueryProject(t *Task) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.ProjectTable, task.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryModelings queries the modelings edge of a Task.
func (c *TaskClient) QueryModelings(t *Task) *ModelingQuery {
	query := (&ModelingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(modeling.Table, modeling.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, task.ModelingsTable, task.ModelingsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	return c.hooks.Task
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	return c.inters.Task
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// TrialClient is a client for the Trial schema.
type TrialClient struct {
	config
}

// NewTrialClient returns a client for the Trial from the given config.
func NewTrialClient(c config) *TrialClient {
	return &TrialClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trial.Hooks(f(g(h())))`.
func (c *TrialClient) Use(hooks ...Hook) {
	c.hooks.Trial = append(c.hooks.Trial, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trial.Intercept(f(g(h())))`.
func (c *TrialClient) Intercept(interceptors ...Interceptor) {
	c.inters.Trial = append(c.inters.Trial, interceptors...)
}

// Create returns a builder for creating a Trial entity.
func (c *TrialClient) Create() *TrialCreate {
	mutation := newTrialMutation(c.config, OpCreate)
	return &TrialCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Trial entities.
func (c *TrialClient) CreateBulk(builders ...*TrialCreate) *TrialCreateBulk {
	return &TrialCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrialClient) MapCreateBulk(slice any, setFunc func(*TrialCreate, int)) *TrialCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrialCreateBulk{err: fmt.Errorf("calling to TrialClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrialCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrialCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Trial.
func (c *TrialClient) Update() *TrialUpdate {
	mutation := newTrialMutation(c.config, OpUpdate)
	return &TrialUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrialClient) UpdateOne(t *Trial) *TrialUpdateOne {
	mutation := newTrialMutation(c.config, OpUpdateOne, withTrial(t))
	return &TrialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrialClient) UpdateOneID(id int) *TrialUpdateOne {
	mutation := newTrialMutation(c.config, OpUpdateOne, withTrialID(id))
	return &TrialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Trial.
func (c *TrialClient) Delete() *TrialDelete {
	mutation := newTrialMutation(c.config, OpDelete)
	return &TrialDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrialClient) DeleteOne(t *Trial) *TrialDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrialClient) DeleteOneID(id int) *TrialDeleteOne {
	builder := c.Delete().Where(trial.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrialDeleteOne{builder}
}

// Query returns a query builder for Trial.
func (c *TrialClient) Query() *TrialQuery {
	return &TrialQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrial},
		inters: c.Interceptors(),
	}
}

// Get returns a Trial entity by its id.
func (c *TrialClient) Get(ctx context.Context, id int) (*Trial, error) {
	return c.Query().Where(trial.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrialClient) GetX(ctx context.Context, id int) *Trial {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryModeling queries the modeling edge of a Trial.
func (c *TrialClient) QueryModeling(t *Trial) *ModelingQuery {
	query := (&ModelingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trial.Table, trial.FieldID, id),
			sqlgraph.To(modeling.Table, modeling.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trial.ModelingTable, trial.ModelingColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TrialClient) Hooks() []Hook {
	return c.hooks.Trial
}

// Interceptors returns the client interceptors.
func (c *TrialClient) Interceptors() []Interceptor {
	return c.inters.Trial
}

func (c *TrialClient) mutate(ctx context.Context, m *TrialMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrialCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrialUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrialDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Trial mutation op: %q", m.Op())
	}
}

// TrialDetailsClient is a client for the TrialDetails schema.
type TrialDetailsClient struct {
	config
}

// NewTrialDetailsClient returns a client for the TrialDetails from the given config.
func NewTrialDetailsClient(c config) *TrialDetailsClient {
	return &TrialDetailsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trialdetails.Hooks(f(g(h())))`.
func (c *TrialDetailsClient) Use(hooks ...Hook) {
	c.hooks.TrialDetails = append(c.hooks.TrialDetails, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trialdetails.Intercept(f(g(h())))`.
func (c *TrialDetailsClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrialDetails = append(c.inters.TrialDetails, interceptors...)
}

// Create returns a builder for creating a TrialDetails entity.
func (c *TrialDetailsClient) Create() *TrialDetailsCreate {
	mutation := newTrialDetailsMutation(c.config, OpCreate)
	return &TrialDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrialDetails entities.
func (c *TrialDetailsClient) CreateBulk(builders ...*TrialDetailsCreate) *TrialDetailsCreateBulk {
	return &TrialDetailsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrialDetailsClient) MapCreateBulk(slice any, setFunc func(*TrialDetailsCreate, int)) *TrialDetailsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrialDetailsCreateBulk{err: fmt.Errorf("calling to TrialDetailsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrialDetailsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrialDetailsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrialDetails.
func (c *TrialDetailsClient) Update() *TrialDetailsUpdate {
	mutation := newTrialDetailsMutation(c.config, OpUpdate)
	return &TrialDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrialDetailsClient) UpdateOne(td *TrialDetails) *TrialDetailsUpdateOne {
	mutation := newTrialDetailsMutation(c.config, OpUpdateOne, withTrialDetails(td))
	return &TrialDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrialDetailsClient) UpdateOneID(id int) *TrialDetailsUpdateOne {
	mutation := newTrialDetailsMutation(c.config, OpUpdateOne, withTrialDetailsID(id))
	return &TrialDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrialDetails.
func (c *TrialDetailsClient) Delete() *TrialDetailsDelete {
	mutation := newTrialDetailsMutation(c.config, OpDelete)
	return &TrialDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrialDetailsClient) DeleteOne(td *TrialDetails) *TrialDetailsDeleteOne {
	return c.DeleteOneID(td.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrialDetailsClient) DeleteOneID(id int) *TrialDetailsDeleteOne {
	builder := c.Delete().Where(trialdetails.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrialDetailsDeleteOne{builder}
}

// Query returns a query builder for TrialDetails.
func (c *TrialDetailsClient) Query() *TrialDetailsQuery {
	return &TrialDetailsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrialDetails},
		inters: c.Interceptors(),
	}
}

// Get returns a TrialDetails entity by its id.
func (c *TrialDetailsClient) Get(ctx context.Context, id int) (*TrialDetails, error) {
	return c.Query().Where(trialdetails.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrialDetailsClient) GetX(ctx context.Context, id int) *TrialDetails {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TrialDetailsClient) Hooks() []Hook {
	return c.hooks.TrialDetails
}

// Interceptors returns the client interceptors.
func (c *TrialDetailsClient) Interceptors() []Interceptor {
	return c.inters.TrialDetails
}

func (c *TrialDetailsClient) mutate(ctx context.Context, m *TrialDetailsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrialDetailsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrialDetailsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrialDetailsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrialDetailsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TrialDetails mutation op: %q", m.Op())
	}
}

// TrialStatusClient is a client for the TrialStatus schema.
type TrialStatusClient struct {
	config
}

// NewTrialStatusClient returns a client for the TrialStatus from the given config.
func NewTrialStatusClient(c config) *TrialStatusClient {
	return &TrialStatusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trialstatus.Hooks(f(g(h())))`.
func (c *TrialStatusClient) Use(hooks ...Hook) {
	c.hooks.TrialStatus = append(c.hooks.TrialStatus, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trialstatus.Intercept(f(g(h())))`.
func (c *TrialStatusClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrialStatus = append(c.inters.TrialStatus, interceptors...)
}

// Create returns a builder for creating a TrialStatus entity.
func (c *TrialStatusClient) Create() *TrialStatusCreate {
	mutation := newTrialStatusMutation(c.config, OpCreate)
	return &TrialStatusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrialStatus entities.
func (c *TrialStatusClient) CreateBulk(builders ...*TrialStatusCreate) *TrialStatusCreateBulk {
	return &TrialStatusCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrialStatusClient) MapCreateBulk(slice any, setFunc func(*TrialStatusCreate, int)) *TrialStatusCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrialStatusCreateBulk{err: fmt.Errorf("calling to TrialStatusClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrialStatusCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrialStatusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrialStatus.
func (c *TrialStatusClient) Update() *TrialStatusUpdate {
	mutation := newTrialStatusMutation(c.config, OpUpdate)
	return &TrialStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrialStatusClient) UpdateOne(ts *TrialStatus) *TrialStatusUpdateOne {
	mutation := newTrialStatusMutation(c.config, OpUpdateOne, withTrialStatus(ts))
	return &TrialStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrialStatusClient) UpdateOneID(id int) *TrialStatusUpdateOne {
	mutation := newTrialStatusMutation(c.config, OpUpdateOne, withTrialStatusID(id))
	return &TrialStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrialStatus.
func (c *TrialStatusClient) Delete() *TrialStatusDelete {
	mutation := newTrialStatusMutation(c.config, OpDelete)
	return &TrialStatusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrialStatusClient) DeleteOne(ts *TrialStatus) *TrialStatusDeleteOne {
	return c.DeleteOneID(ts.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrialStatusClient) DeleteOneID(id int) *TrialStatusDeleteOne {
	builder := c.Delete().Where(trialstatus.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrialStatusDeleteOne{builder}
}

// Query returns a query builder for TrialStatus.
func (c *TrialStatusClient) Query() *TrialStatusQuery {
	return &TrialStatusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrialStatus},
		inters: c.Interceptors(),
	}
}

// Get returns a TrialStatus entity by its id.
func (c *TrialStatusClient) Get(ctx context.Context, id int) (*TrialStatus, error) {
	return c.Query().Where(trialstatus.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrialStatusClient) GetX(ctx context.Context, id int) *TrialStatus {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TrialStatusClient) Hooks() []Hook {
	return c.hooks.TrialStatus
}

// Interceptors returns the client interceptors.
func (c *TrialStatusClient) Interceptors() []Interceptor {
	return c.inters.TrialStatus
}

func (c *TrialStatusClient) mutate(ctx context.Context, m *TrialStatusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrialStatusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrialStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrialStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrialStatusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TrialStatus mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserGroupClient is a client for the UserGroup schema.
type UserGroupClient struct {
	config
}

// NewUserGroupClient returns a client for the UserGroup from the given config.
func NewUserGroupClient(c config) *UserGroupClient {
	return &UserGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usergroup.Hooks(f(g(h())))`.
func (c *UserGroupClient) Use(hooks ...Hook) {
	c.hooks.UserGroup = append(c.hooks.UserGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usergroup.Intercept(f(g(h())))`.
func (c *UserGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserGroup = append(c.inters.UserGroup, interceptors...)
}

// Create returns a builder for creating a UserGroup entity.
func (c *UserGroupClient) Create() *UserGroupCreate {
	mutation := newUserGroupMutation(c.config, OpCreate)
	return &UserGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserGroup entities.
func (c *UserGroupClient) CreateBulk(builders ...*UserGroupCreate) *UserGroupCreateBulk {
	return &UserGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserGroupClient) MapCreateBulk(slice any, setFunc func(*UserGroupCreate, int)) *UserGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserGroupCreateBulk{err: fmt.Errorf("calling to UserGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserGroup.
func (c *UserGroupClient) Update() *UserGroupUpdate {
	mutation := newUserGroupMutation(c.config, OpUpdate)
	return &UserGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserGroupClient) UpdateOne(ug *UserGroup) *UserGroupUpdateOne {
	mutation := newUserGroupMutation(c.config, OpUpdateOne, withUserGroup(ug))
	return &UserGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserGroupClient) UpdateOneID(id int) *UserGroupUpdateOne {
	mutation := newUserGroupMutation(c.config, OpUpdateOne, withUserGroupID(id))
	return &UserGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserGroup.
func (c *UserGroupClient) Delete() *UserGroupDelete {
	mutation := newUserGroupMutation(c.config, OpDelete)
	return &UserGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserGroupClient) DeleteOne(ug *UserGroup) *UserGroupDeleteOne {
	return c.DeleteOneID(ug.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserGroupClient) DeleteOneID(id int) *UserGroupDeleteOne {
	builder := c.Delete().Where(usergroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserGroupDeleteOne{builder}
}

// Query returns a query builder for UserGroup.
func (c *UserGroupClient) Query() *UserGroupQuery {
	return &UserGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a UserGroup entity by its id.
func (c *UserGroupClient) Get(ctx context.Context, id int) (*UserGroup, error) {
	return c.Query().Where(usergroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserGroupClient) GetX(ctx context.Context, id int) *UserGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserGroupClient) Hooks() []Hook {
	return c.hooks.UserGroup
}

// Interceptors returns the client interceptors.
func (c *UserGroupClient) Interceptors() []Interceptor {
	return c.inters.UserGroup
}

func (c *UserGroupClient) mutate(ctx context.Context, m *UserGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserGroup mutation op: %q", m.Op())
	}
}

// UserProjectClient is a client for the UserProject schema.
type UserProjectClient struct {
	config
}

// NewUserProjectClient returns a client for the UserProject from the given config.
func NewUserProjectClient(c config) *UserProjectClient {
	return &UserProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userproject.Hooks(f(g(h())))`.
func (c *UserProjectClient) Use(hooks ...Hook) {
	c.hooks.UserProject = append(c.hooks.UserProject, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userproject.Intercept(f(g(h())))`.
func (c *UserProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserProject = append(c.inters.UserProject, interceptors...)
}

// Create returns a builder for creating a UserProject entity.
func (c *UserProjectClient) Create() *UserProjectCreate {
	mutation := newUserProjectMutation(c.config, OpCreate)
	return &UserProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserProject entities.
func (c *UserProjectClient) CreateBulk(builders ...*UserProjectCreate) *UserProjectCreateBulk {
	return &UserProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserProjectClient) MapCreateBulk(slice any, setFunc func(*UserProjectCreate, int)) *UserProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserProjectCreateBulk{err: fmt.Errorf("calling to UserProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserProject.
func (c *UserProjectClient) Update() *UserProjectUpdate {
	mutation := newUserProjectMutation(c.config, OpUpdate)
	return &UserProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserProjectClient) UpdateOne(up *UserProject) *UserProjectUpdateOne {
	mutation := newUserProjectMutation(c.config, OpUpdateOne, withUserProject(up))
	return &UserProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserProjectClient) UpdateOneID(id int) *UserProjectUpdateOne {
	mutation := newUserProjectMutation(c.config, OpUpdateOne, withUserProjectID(id))
	return &UserProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserProject.
func (c *UserProjectClient) Delete() *UserProjectDelete {
	mutation := newUserProjectMutation(c.config, OpDelete)
	return &UserProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserProjectClient) DeleteOne(up *UserProject) *UserProjectDeleteOne {
	return c.DeleteOneID(up.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserProjectClient) DeleteOneID(id int) *UserProjectDeleteOne {
	builder := c.Delete().Where(userproject.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserProjectDeleteOne{builder}
}

// Query returns a query builder for UserProject.
func (c *UserProjectClient) Query() *UserProjectQuery {
	return &UserProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserProject},
		inters: c.Interceptors(),
	}
}

// Get returns a UserProject entity by its id.
func (c *UserProjectClient) Get(ctx context.Context, id int) (*UserProject, error) {
	return c.Query().Where(userproject.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserProjectClient) GetX(ctx context.Context, id int) *UserProject {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a UserProject.
func (c *UserProjectClient) QueryProject(up *UserProject) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := up.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userproject.Table, userproject.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userproject.ProjectTable, userproject.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(up.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserProjectClient) Hooks() []Hook {
	return c.hooks.UserProject
}

// Interceptors returns the client interceptors.
func (c *UserProjectClient) Interceptors() []Interceptor {
	return c.inters.UserProject
}

func (c *UserProjectClient) mutate(ctx context.Context, m *UserProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserProject mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Configuration, Dataset, DatasetRoot, Device, EngineLog, Gpu, HyperParamsHistory,
		Menu, Modeling, ModelingDetails, ModelingModels, Project, Task, Trial,
		TrialDetails, TrialStatus, User, UserGroup, UserProject []ent.Hook
	}
	inters struct {
		Configuration, Dataset, DatasetRoot, Device, EngineLog, Gpu, HyperParamsHistory,
		Menu, Modeling, ModelingDetails, ModelingModels, Project, Task, Trial,
		TrialDetails, TrialStatus, User, UserGroup, UserProject []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
